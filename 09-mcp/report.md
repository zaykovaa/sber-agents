# Отчет о реализации MCP инструмента для банковского агента

## 1. Какой новый инструмент вы реализовали?

Был реализован новый инструмент **`calculate_deposit_profit`** - калькулятор доходности вклада с учетом капитализации процентов.

### Описание инструмента:
- **Название**: `calculate_deposit_profit`
- **Тип**: MCP инструмент (Model Context Protocol)
- **Назначение**: Расчет итоговой суммы вклада, полученного дохода и эффективной ставки
- **Расположение**: `mcp/mcp-bank-agent/server.py`

### Параметры:
- `initial_amount` (float, ≥1000) - начальная сумма вклада в рублях
- `annual_rate` (float, 0-100%) - годовая процентная ставка
- `term_months` (int, 1-60) - срок вклада в месяцах
- `capitalization` (bool, default=False) - капитализация процентов

## 2. Как работает ваш инструмент? Примеры использования

### Алгоритм работы:

1. **С капитализацией процентов** (сложный процент):
   - Формула: `A = P * (1 + r/12)^n`
   - Где: P - начальная сумма, r - годовая ставка, n - срок в месяцах
   - Ежемесячное начисление процентов на проценты

2. **Без капитализации** (простой процент):
   - Формула: `A = P * (1 + r * n/12)`
   - Где: P - начальная сумма, r - годовая ставка, n - срок в месяцах
   - Простое начисление процентов на начальную сумму

3. **Расчет результатов**:
   - Итоговая сумма = начальная сумма + начисленные проценты
   - Доход = итоговая сумма - начальная сумма
   - Эффективная ставка = (доход / начальная сумма) / срок в годах * 100

### Примеры использования:

#### Пример 1: Вклад с капитализацией
```
Параметры:
- Начальная сумма: 100,000 ₽
- Годовая ставка: 10%
- Срок: 12 месяцев
- Капитализация: да

Результат:
- Итоговая сумма: 110,471.31 ₽
- Доход: 10,471.31 ₽
- Эффективная ставка: 10.47% годовых
```

#### Пример 2: Вклад без капитализации
```
Параметры:
- Начальная сумма: 500,000 ₽
- Годовая ставка: 15%
- Срок: 6 месяцев
- Капитализация: нет

Результат:
- Итоговая сумма: 537,500.00 ₽
- Доход: 37,500.00 ₽
- Эффективная ставка: 15.00% годовых
```

#### Пример 3: Долгосрочный вклад
```
Параметры:
- Начальная сумма: 1,000,000 ₽
- Годовая ставка: 12%
- Срок: 36 месяцев
- Капитализация: да

Результат:
- Итоговая сумма: 1,430,768.78 ₽
- Доход: 430,768.78 ₽
- Эффективная ставка: 14.36% годовых
```

### Интеграция с агентом:

Инструмент доступен агенту через MCP сервер. Агент может вызывать его автоматически при вопросах пользователя о расчете доходности вклада:

```
Пользователь: "Посчитай, сколько я получу, если положу 200 тысяч на 12 месяцев под 12% с капитализацией?"

Агент вызывает: calculate_deposit_profit(
    initial_amount=200000,
    annual_rate=12.0,
    term_months=12,
    capitalization=True
)
```

## 3. Подключали ли MCP сервер к другим клиентам? Как это работало?

### Текущая архитектура:

MCP сервер подключен к **LangChain агенту** через библиотеку `langchain-mcp-adapters`:

```python
# src/agent.py
from langchain_mcp_adapters.client import MultiServerMCPClient

mcp_client = MultiServerMCPClient({
    "mcp-bank-agent": {
        "transport": "streamable_http",
        "url": "http://localhost:8000/mcp"
    }
})

mcp_tools = await mcp_client.get_tools()
tools.extend(mcp_tools)  # Добавляем MCP инструменты к локальным
```

### Как это работает:

1. **При инициализации агента**:
   - Агент подключается к MCP серверу по HTTP
   - Получает список доступных инструментов (search_products, currency_converter, calculate_deposit_profit)
   - Автоматически добавляет их в свой набор инструментов

2. **Во время работы**:
   - Агент может вызывать MCP инструменты так же, как локальные
   - Все инструменты доступны через единый интерфейс
   - MCP сервер обрабатывает запросы асинхронно

3. **Преимущества такой архитектуры**:
   - Разделение ответственности: бизнес-логика в MCP сервере, агент - только координатор
   - Легкое добавление новых инструментов без изменения кода агента
   - Возможность переиспользования MCP сервера другими клиентами

### Другие возможные клиенты:

MCP сервер может быть подключен к любым клиентам, поддерживающим MCP протокол:
- Другие LangChain агенты
- Claude Desktop (через MCP интеграцию)
- Кастомные приложения через MCP SDK
- Другие LLM фреймворки с поддержкой MCP

## 4. Какие преимущества MCP вы заметили?

### 1. **Модульность и разделение ответственности**
- Бизнес-логика изолирована в отдельном сервисе
- Агент не знает деталей реализации инструментов
- Легко тестировать и разрабатывать инструменты независимо

### 2. **Гибкость и расширяемость**
- Новые инструменты добавляются без изменения кода агента
- Можно обновлять инструменты независимо от агента
- Легко версионировать API инструментов

### 3. **Переиспользование**
- Один MCP сервер может обслуживать несколько клиентов
- Инструменты доступны разным агентам и приложениям
- Централизованное управление бизнес-логикой

### 4. **Стандартизация**
- Единый протокол для всех инструментов
- Автоматическая генерация схемы инструментов
- Совместимость с различными клиентами

### 5. **Асинхронность**
- MCP инструменты могут быть асинхронными
- Поддержка долгих операций без блокировки агента
- Эффективное использование ресурсов

### 6. **Типизация и валидация**
- Автоматическая валидация параметров через Pydantic
- Типобезопасность на уровне протокола
- Автоматическая генерация документации

## 5. С какими сложностями столкнулись?

### 1. **Перенос инструмента из локальных в MCP**

**Проблема**: Изначально инструмент был реализован как локальный LangChain tool в `tools.py`, затем нужно было перенести его в MCP сервер.

**Решение**: 
- Удалили декоратор `@tool` из LangChain
- Добавили декоратор `@mcp.tool` из FastMCP
- Убрали импорт из `agent.py`
- MCP сервер автоматически экспортирует инструмент

**Урок**: Важно сразу решить, где будет жить инструмент - локально или в MCP сервере.

### 2. **Синхронизация типов и аннотаций**

**Проблема**: Нужно было сохранить все аннотации типов и валидацию при переносе.

**Решение**: Использовали одинаковые `Annotated` и `Field` из Pydantic, которые работают и в LangChain, и в MCP.

**Урок**: Pydantic обеспечивает единообразие валидации в разных контекстах.

### 3. **Асинхронность функций**

**Проблема**: MCP инструменты должны быть асинхронными (`async def`), в то время как локальные LangChain инструменты могут быть синхронными.

**Решение**: Переписали функцию как `async def`, хотя она не использует await. FastMCP корректно обрабатывает такие функции.

**Урок**: MCP требует асинхронного интерфейса, даже если реализация синхронная.

### 4. **Логирование и отладка**

**Проблема**: Сложнее отлаживать инструменты, работающие через HTTP.

**Решение**: 
- Добавили подробное логирование в MCP сервер
- Использовали структурированные логи с контекстом
- Проверяли работу через прямые HTTP запросы к серверу

**Урок**: Важно иметь хорошее логирование для распределенных систем.

### 5. **Зависимости и окружение**

**Проблема**: MCP сервер и агент могут иметь разные зависимости и окружения.

**Решение**: 
- MCP сервер имеет свой `pyproject.toml` и виртуальное окружение
- Агент подключается через HTTP, не требуя общих зависимостей
- Использовали `uv` для управления зависимостями

**Урок**: MCP позволяет изолировать зависимости между компонентами.

### 6. **Обработка ошибок**

**Проблема**: Нужно корректно обрабатывать ошибки и возвращать понятные сообщения пользователю.

**Решение**: 
- Добавили try-except блоки в инструменте
- Возвращаем понятные сообщения об ошибках
- Логируем ошибки для отладки

**Урок**: Пользователь должен получать понятные сообщения об ошибках, а не технические детали.

## Выводы

Реализация инструмента через MCP показала следующие преимущества:

1. **Чистая архитектура**: Разделение между агентом и бизнес-логикой
2. **Легкое расширение**: Новые инструменты добавляются без изменения агента
3. **Переиспользование**: Один сервер для множества клиентов
4. **Стандартизация**: Единый протокол для всех инструментов

Основные сложности были связаны с:
- Переносом кода между контекстами (локальный → MCP)
- Пониманием асинхронной природы MCP
- Отладкой распределенной системы

В целом, MCP оказался отличным решением для создания модульных и расширяемых AI агентов.

